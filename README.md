# Лабораторная работа №2

---

**Выполнил:** Данченко Владимир Витальевич, 368087
**Группа:** P3334
**Вариант:** pre-bag(Prefix Tree, Bag)

---

# Цель:

Освоиться с построением пользовательских типов данных, полиморфизмом, рекурсивными алгоритмами и средствами тестирования (unit testing, property-based testing).

---

## Требования к разработанному ПО:

1. Реализовать функции:
    - добавление и удаление элементов;
    - фильтрация;
    - отображение (map);
    - свертки (левая и правая);
    - структура должна быть моноидом.

2. Структуры данных должны быть неизменяемыми.
3. Библиотека должна быть протестирована в рамках unit testing.
4. Библиотека должна быть протестирована в рамках property-based testing (как минимум 3 свойства, включая свойства моноида).
5. Структура должна быть полиморфной.
6. Использовать идиоматичный для технологии стиль программирования. Примечание: некоторые языки позволяют получить большую часть API через реализацию небольшого интерфейса. Так как лабораторная работа про ФП, а не про экосистему языка -- необходимо реализовать их вручную и по возможности -- обеспечить совместимость.

## Реализация

[tail.clj](task8/tail.clj)

Я преобразовал строку в список цифр и разбивал его на части так, чтоб в каждой части было 13 элементов(с помощью `partition`)

Хвостовую рекурсию использовал для вычисления произведения цифр в последовательности
```clojure
(defn product [digits acc]
  (if (empty? digits)
    acc
    (recur (rest digits) (* acc (first digits)))))
```
Далее находил максимальную часть из 13 цифр
Данный подход хорошо использовать для последовательных операций.

### 2. Рекурсия
[rec.clj](task8/rec.clj)

Я преобразовал строку в список цифр и разбивал его на части так, чтоб в каждой части было 13 элементов(с помощью `partition`)

Рекурсию использовал для вычисления произведения части цифр
```clojure
(defn product [digits]
      (reduce * digits))
```
Далее находил максимальную часть из 13 цифр
Данный подход хорошо использовать для последовательности одинаковых операций.

### 3. Модульная реализация
[modular.clj](task8/modular.clj)

Здесь я явно разделили генерацию последовательности(`partition`), фильтрацию(`filter`) и нахождения произведения(`reduce`)
```clojure
(defn find-max-product-modular [number-string]
      (let [digits (str-digits number-string)
            sequences (generate-sequences digits)
            valid-sequences (filter-sequences sequences)]
           (reduce max (map product valid-sequences))))
```
Данное решение за счет модульности более читаемо и понятно

### 4. Map
[map.clj](task8/map.clj)

Я использовал map, для того чтоб применить функцию `product`(она умножает все числа) к каждой части
```clojure
(defn find-max-product-map [digits]
      (->> digits
           (#(partition 13 1 %))
           (map product)
           (apply max)))
```
Данное решение имеет минимальное количество кода

## Проблема №23

Вся суть проблемы 23 - это нахождение суммы всех чисел до 28123, которые невозможно записать, как сумму двух избыточных чисел.
При решении данной проблемы, я использовал: циклы и бесконечные последовательности

### 1. Циклы
[loop.clj](task23/loop.clj)

Я использовал циклы в двух функциях: `divisor`(нахождение собственных делителей числа) и `abundant-numbers`(создания списка избыточных чисел)
```clojure
(defn divisors [n]
      (loop [i 1
             result []]
            (if (>= i (inc (quot n 2)))
              result
              (if (zero? (mod n i))
                (recur (inc i) (conj result i)) ; добавляем делитель и продолжаем
                (recur (inc i) result))))) ; продолжаем без добавления

(def abundant-numbers
      (loop [n 12
             result []]
            (if (> n limit)
              result
              (if (abundant? n)
                (recur (inc n) (conj result n)) ; Добавляем n в результат и продолжаем
                (recur (inc n) result))))) ; Продолжаем без добавления
```
Данных подход итеративно выполняет задачи и избегает рекурсивного вызова

### 2. Бесконечные последовательности
[lazy.clj](task23/lazy.clj)

Я создаю бесконечную последовательность избыточных чисел
```clojure
(defn abundant-numbers []
      (filter abundant? (iterate inc 1)))
```
Данных подход позволяет создавать бесконечную последовательность и взаимодействовать с ней

---

## Вывод

Выполняя данную лабораторную работу я узнал основы языка Clojure, освоил такие приёмы, как рекурсия, функции высшего порядка и работа с ленивыми структурами данных.
Практическое применение этих решений на примере задач проекта Эйлера подтвердило их эффективность и целесообразность использования в реальных проектах.

